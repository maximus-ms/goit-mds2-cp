# ESP32-S3: Реалізація Системи Детекції Аномалій на 4-Мікрофонній Решітці з Few-Shot Learning

---

## Зміст

1. [Вступ](#вступ)
2. [Апаратна частина: Підключення 4 мікрофонів до ESP32-S3](#1-апаратна-частина-підключення-4-мікрофонів-до-esp32-s3)
   - [1.1 Використання двох I2S контролерів](#11-використання-двох-i2s-контролерів-рекомендовано-для-inmp441)
   - [1.2 TDM режим (Time Division Multiplexing)](#12-tdm-режим-time-division-multiplexing)
3. [Алгоритм Siamese Network для Аномалій](#2-алгоритм-siamese-network-для-аномалій)
   - [2.1 Етап А: Навчання (Enrollment)](#21-етап-а-навчання-enrollment)
   - [2.2 Етап Б: Моніторинг (Inference)](#22-етап-б-моніторинг-inference)
4. [Оптимізація на ESP32-S3 (Xtensa LX7)](#3-оптимізація-на-esp32-s3-xtensa-lx7)
5. [Рекомендований стек для реалізації](#рекомендований-стек-для-реалізації)

---

## Вступ

Комбінація **4-мікрофонної решітки** та **Siamese Networks (Few-Shot Learning)** підходить для архітектури ESP32-S3. Це дозволяє реалізувати систему, яка навчається "нормальному" стану конкретного механізму прямо на пристрої без необхідності збирати великі датасети поломок.

Такий підхід дозволяє створити MVP, який є **агностичним до типу машини** (*fan-agnostic* / *motor-agnostic*) — він просто вивчає "звуковий підпис" того, на що його почепили.

---

## 1. Апаратна частина: Підключення 4 мікрофонів до ESP32-S3

Оскільки планується використовувати доступні модулі (найімовірніше **INMP441** або подібні I2S MEMS мікрофони), важливо врахувати особливості шини I2S.

Стандартні мікрофони **INMP441** мають лише **L/R** (*Left/Right*) селектор, тобто на одну лінію даних можна "повісити" максимум **2 мікрофони**.

Для підключення **4 мікрофонів** на ESP32-S3 є два шляхи:

### 1.1 Використання двох I2S контролерів (Рекомендовано для INMP441)

ESP32-S3 має два незалежних I2S периферійних модулі (`I2S0` та `I2S1`). Можна підключити одну пару мікрофонів до `I2S0`, а іншу — до `I2S1`.

**Переваги:**
- Це дозволяє синхронно читати 4 канали
- Простіше в реалізації для стандартних мікрофонів INMP441

**Важливо:** Потрібно буде продомати синхронізацію буферів даних з обох контролерів, щоб семпли відповідали одному часовому моменту для коректного beamforming-у.

#### Схема підключення

| Контролер | Мікрофони | GPIO (BCLK) | GPIO (WS) | GPIO (DATA) |
|-----------|-----------|-------------|-----------|-------------|
| **I2S0** | INMP441 #1 (L) | GPIO 41 | GPIO 42 | GPIO 2 |
| **I2S0** | INMP441 #2 (R) | GPIO 41 | GPIO 42 | GPIO 2 |
| **I2S1** | INMP441 #3 (L) | GPIO 17 | GPIO 18 | GPIO 19 |
| **I2S1** | INMP441 #4 (R) | GPIO 17 | GPIO 18 | GPIO 19 |

### 1.2 TDM режим (Time Division Multiplexing)

ESP32-S3 підтримує **TDM**, що дозволяє читати до **16 каналів** на одній лінії. Проте, дешеві модулі INMP441 зазвичай **не підтримують TDM** (вони використовують стандартний Philips I2S).

**Для TDM потрібні специфічні чіпи:**
- ICS-43434
- Масиви з AC108 АЦП

Ці рішення значно дорожчі або складніші. Тому варіант з двома I2S портами є кращим для дипломного проєкту.

---

## 2. Алгоритм Siamese Network для Аномалій

Ідея спробувати **One-Class Classification** або **Few-Shot Anomaly Detection**.:

### 2.1 Етап А: Навчання (Enrollment)

1. **Записуємо** 10 секунд звуку "нормальної" роботи
2. **Розбиваємо** аудіо на вікна (наприклад, по 1 секунді з перекриттям)
3. **Проганяємо** кожне вікно через **Feature Extractor** (енкодер нейромережі)
4. **Отримуємо** набір векторів (ембедінгів) $v_1, v_2, \ldots, v_N$
5. **Обчислюємо** усереднений "вектор-центроїд" (*Prototype Vector*) $C$, який зберігаємо в енергонезалежну пам'ять (*NVS/Flash*):

$$C = \frac{1}{N} \sum_{i=1}^{N} v_i$$

#### Блок-схема процесу навчання

```
[Аудіо 10 сек] → [Вікна 1 сек] → [Feature Extractor] → [Ембедінги v₁...vₙ] → [Центроїд C] → [Flash/NVS]
```

### 2.2 Етап Б: Моніторинг (Inference)

1. **Отримуємо** новий фрагмент аудіо, перетворюємо його на вектор $v_{new}$ через ту ж нейромережу
2. **Обчислюємо** **Косинусну відстань** (*Cosine Distance*) між новим вектором та збереженим центроїдом

   Це ефективніше за евклідову відстань у багатовимірних просторах, оскільки ігнорує амплітуду (гучність) і фокусується на структурі сигналу.

   $$D_{cos}(v_{new}, C) = 1 - \frac{v_{new} \cdot C}{\|v_{new}\| \|C\|}$$

   Де:
   - $\cdot$ — скалярний добуток
   - $\|v\|$ — норма вектора

3. **Порівнюємо** з порогом: якщо $D_{cos} > \text{Threshold}$, фіксуємо аномалію

#### Блок-схема процесу моніторингу

```
[Новий аудіо] → [Feature Extractor] → [v_new] → [Cosine Distance] → [Порівняння з Threshold] → [Аномалія?]
                                                      ↑
                                                   [C з Flash]
```

#### Переваги косинусної відстані

| Метрика | Евклідова відстань | Косинусна відстань |
|---------|-------------------|-------------------|
| **Чутливість до амплітуди** | Так | Ні |
| **Фокус на структурі** | Ні | Так |
| **Обчислювальна складність** | $O(n)$ | $O(n)$ |
| **Ефективність для аудіо** | Середня | Висока |

---

## 3. Оптимізація на ESP32-S3 (Xtensa LX7)

### 3.1 Векторизація Distance Calculation

Обчислення косинусної відстані вимагає багато операцій множення та додавання. Використовуючи **ESP-DSP** або прямі SIMD інструкції Xtensa, можна спробувати прискорити операцію скалярного добутку (*Dot Product*) у **5-10 разів** порівняно зі звичайним C++ циклом.

#### Приклад оптимізації

**Наївна реалізація (C++):**
```cpp
float dot_product(const float* a, const float* b, int len) {
    float sum = 0.0f;
    for (int i = 0; i < len; i++) {
        sum += a[i] * b[i];
    }
    return sum;
}
```

**Векторизована реалізація (ESP-DSP):**
```cpp
#include "dsps_dotprod_f32.h"

float dot_product_optimized(const float* a, const float* b, int len) {
    float result;
    dsps_dotprod_f32(a, b, &result, len);
    return result;
}
```

### 3.2 Архітектура Енкодера

Для отримання ембедінгів не обов'язково використовувати важкі трансформери. Ефективним варіантом для S3 буде:

- **1D-CNN** — для прямого обробки аудіо сигналу
- **Tiny 2D-CNN** — на вхід подається спектрограма Mel-Spectrogram

Бібліотека **ESP-DL** від Espressif має оптимізовані версії:
- Шарів згортки (*Conv2D*)
- Квантування (*8-bit int*)

Це дозволить моделі працювати в реальному часі, або наближеному до реального.

#### Порівняння архітектур

| Архітектура | Параметри | Швидкість інференсу | Точність |
|------------|-----------|---------------------|----------|
| **Transformer (KWT)** | ~500K | Повільна | Висока |
| **2D-CNN (Tiny)** | ~50K | Швидка | Середня |
| **1D-CNN** | ~20K | Дуже швидка | Середня |

---

## Рекомендований стек для реалізації

### Таблиця технологій

| Компонент | Технологія | Призначення |
|-----------|-----------|-------------|
| **Framework** | ESP-IDF (C/C++) | Максимальний контроль над двома I2S портами та DMA |
| **DSP** | `esp-dsp` | Швидке FFT (перетворення спектрограми) та векторні операції |
| **ML** | `ESP-DL` або TensorFlow Lite Micro | `ESP-DL` краще оптимізована під S3 (використовує векторні інструкції "з коробки") |
| **Hardware** | ESP32-S3 DevKit + 4× INMP441 | Або подібне |

### Детальний опис компонентів

#### 1. Framework: ESP-IDF (C/C++)

**Переваги:**
- Прямий доступ до периферії (I2S0, I2S1)
- Ефективне управління DMA буферами
- Підтримка FreeRTOS для багатозадачності

#### 2. DSP: `esp-dsp`

**Основні функції:**
- `dsps_fft2r_fc32()` — швидке перетворення Фур'є
- `dsps_dotprod_f32()` — векторний скалярний добуток
- `dsps_wind_hann_f32()` — віконні функції для спектрограм

#### 3. ML: `ESP-DL`

**Переваги над TensorFlow Lite:**
- Нативна оптимізація під Xtensa LX7
- Підтримка квантування int8/int16
- Оптимізовані шари згортки та матричного множення

#### 4. Hardware: ESP32-S3 DevKit + 4× INMP441

**Характеристики INMP441:**
- Інтерфейс: I2S (Philips стандарт)
- Роздільність: 24-bit
- Частота дискретизації: до 48 кГц
- Чутливість: -26 dBFS
- Ціна: ~$1-2 за модуль

---

## Висновки

Таким чином ми можемо:

✅ **Реалізувати систему детекції аномалій** без необхідності збирати великі датасети  
✅ **Використовувати стандартні компоненти** (INMP441) за доступною ціною  
✅ **Оптимізувати продуктивність** через векторні інструкції Xtensa LX7  
✅ **Створити агностичне рішення**, яке працює з будь-яким типом механізму  
